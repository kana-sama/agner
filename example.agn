-module(main).

-record(termin, {raw}).
-record(entity, {raw}).
-record(rule, {ctor, entity, points}).
-record(grammar, {rules}).

pretty_point(#termin{raw = X}) -> [{fg,  blue, [X]}];
pretty_point(#entity{raw = X}) -> [{fg, green, [X]}].

parse_point(Cs = [C|_]) when chars:is_upper(C) -> #entity{raw=Cs};
parse_point(Cs) -> #termin{raw=Cs}.

pretty_rule(Rule) -> [
  {fg, magenta, [Rule#rule.ctor]},
  {fg, red, [" . "]},
  pretty_point(Rule#rule.entity),
  {fg, red, [" = "]},
  lists:intersperse(" ", lists:map(fun pretty_point/1, Rule#rule.points)),
  "\n"
].

parse_rule(S) ->
  [Ctor, ".", E, "=" | Points] = lists:words(S),
  #rule{
    ctor = Ctor,
    entity = #entity{raw=E},
    points = lists:map(fun parse_point/1, Points)
  }.

pretty_grammar(Grammar) ->
  lists:map(fun pretty_rule/1, Grammar#grammar.rules).

parse_grammar(S) ->
  #grammar{rules = lists:map(fun parse_rule/1, lists:lines(S))}.

main() ->
  Grammar =
    " s . S = E
      + . E = E + F
      - . E = E - F
      F . E = F
      * . F = F * T
      / . F = F / T
      T . F = T
      i . T = <int>
      i . T = ( E )
      g . T = ( E : Ty )
      e . Ty = int ",
  sgr:println(pretty_grammar(parse_grammar(Grammar))).
